<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-12-31 Sun 22:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Twelve Days of Christmas #9</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Daniel Quernheim" />
<link rel='stylesheet' href='/style.css' type='text/css'/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="preamble" class="status">
<div id='nav'><a href="/">home</a></div>
</div>
<div id="content">
<h1 class="title">Twelve Days of Christmas #9</h1>
<p>
This is the ninth part of <a href="../index.html">a chess-themed tutorial</a> on writing an SPA in
<a href="https://github.com/OvermindDL1/bucklescript-tea">Bucklescript-TEA</a>.  After this part, your app will look similar to <a href="demo.html">this demo</a>.
</p>

<p>
 Today, we will use parser
combinators to be able to read the most widespread format for storing
chess games, the PGN format.  Start from tag <code>day8</code> if you are following along with my
repository.
</p>

<div id="outline-container-orgb93ef88" class="outline-2">
<h2 id="orgb93ef88">What is a parser combinator?</h2>
<div class="outline-text-2" id="text-orgb93ef88">
<p>
Every once in a while you have to deal with string data instead of
JSON data.  A <i>parser</i> processes a string and analyzes it in order build a data
structure such as an OCaml record, according to a set of rules.  There
are two widespread approaches to writing parsers:  A <i>parser
generator</i> takes as its input a formal grammar written in a certain
format, and returns the actual parser function.  Thus, the generator
needs to be run every time the grammar is changed, but the generated
parser is a standalone function.
</p>

<p>
<i>Parser combinators</i> on the other hand are a convenient way of
building parsers on the fly from
smaller units without having to specify the grammar in a different
language, much like the way we built JSON decoders from building
blocks.  In this part of the tutorial, we will build a parser
using parser combinators for the textual representation of chess games called PGN.
</p>

<p>
We will use a small self-contained parser combinator library and only
touch very lightly on technical matters.
If you&rsquo;re interested in learning more about parser combinators and
maybe even writing your own parser combinator library, you
should check out <a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Scott Wlaschin&rsquo;s &ldquo;Understanding Parser Combinators&rdquo;
series</a>.  It&rsquo;s aimed at F#, but F# and OCaml share a lot of similarities.
</p>

<p>
Essentially, a parser combinator is a function that takes parsers as
its arguments and returns a new parser.  A parser, on the other hand,
is a function that takes a string as its argument and returns
something else.  Compare that to what you learned about JSON decoders
earlier.  The combinators that we used there were <code>list</code>, <code>field</code>,
<code>map2</code> etc. 
</p>

<p>
I chose to use a <a href="https://github.com/pyrocat101/opal">small self-contained
implementation of parser combinators called Opal</a>.  Just drop <code>opal.ml</code>
into your <code>src</code> directory.  Today&rsquo;s part of this tutorial is a little
different from the others because most of the action is going to
happen in the terminal.  To get you acquainted with parser
combinators, let&rsquo;s explore them in an interactive way in the OCaml
toplevel (the read-eval-print loop).  Open a terminal and type <code>ocaml</code>, or better yet, <code>utop</code>.  <a href="https://github.com/diml/utop">Utop</a> offers readline support and
tab-completion, and is more colorful :-)  You can install it through
OPAM with <code>opam install utop</code>.
</p>

<p>
Utop will greet you with a prompt like <code>utop #</code>.  Let&rsquo;s load
<code>src/opal.ml</code>.  Note that you have to end a statement with <code>;;</code> in Utop.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #a52a2a;">#</span> <span style="color: #a52a2a;">#</span>use <span style="color: #008000;">"src/opal.ml"</span><span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
You&rsquo;ll see the <i>signature</i> of Opal, listing all the types and
functions that it exposes.
</p>

<p>
Are you ready to write your first parser? There it is:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #a52a2a;">#</span> <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #BA36A5;">pgn_capture</span> <span style="color: #a52a2a;">=</span> exactly <span style="color: #008000;">'x'</span><span style="color: #ff4500;">;;</span>
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #006699;">capture</span> <span style="color: #a52a2a;">:</span> char input <span style="color: #a52a2a;">-&gt;</span> <span style="color: #a52a2a;">(</span>char <span style="color: #a52a2a;">*</span> char input<span style="color: #a52a2a;">)</span> option <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">&lt;</span><span style="color: #0000FF;">fun</span><span style="color: #a52a2a;">&gt;</span>
</pre>
</div>

<p>
OCaml tells you that <code>capture</code> is a function that takes a <code>char input</code>
and either returns <code>None</code> (if the parser failed) or <code>Some</code> pair of
<code>char</code> (the result of applying the parser to the input) and
another <code>char input</code> (the remaining input).  Building a parser using
parser combinators is all about making the parsers work together so
that each parser feeds the remaining input into the next parser.
</p>

<p>
Let&rsquo;s try out our parser. We can convert a string into type <code>input</code> by
using <code>LazyStream.of_string</code>:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #a52a2a;">#</span> <span style="color: #6434A3;">LazyStream.</span>of_string<span style="color: #ff4500;">;;</span>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> bytes <span style="color: #a52a2a;">-&gt;</span> char input <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">&lt;</span><span style="color: #0000FF;">fun</span><span style="color: #a52a2a;">&gt;</span>

utop <span style="color: #a52a2a;">#</span> <span style="color: #6434A3;">LazyStream.</span>of_string <span style="color: #008000;">"x"</span> <span style="color: #a52a2a;">|&gt;</span> pgn_capture<span style="color: #ff4500;">;;</span>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #a52a2a;">(</span>char <span style="color: #a52a2a;">*</span> char input<span style="color: #a52a2a;">)</span> option <span style="color: #a52a2a;">=</span> <span style="color: #000000; background-color: #FFFFFF;">Some</span> <span style="color: #a52a2a;">(</span><span style="color: #008000;">'x'</span><span style="color: #a52a2a;">,</span> <span style="color: #6434A3;">LazyStream.</span><span style="color: #000000; background-color: #FFFFFF;">Nil</span><span style="color: #a52a2a;">)</span>

utop <span style="color: #a52a2a;">#</span> <span style="color: #6434A3;">LazyStream.</span>of_string <span style="color: #008000;">"xyz"</span> <span style="color: #a52a2a;">|&gt;</span> pgn_capture<span style="color: #ff4500;">;;</span>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #a52a2a;">(</span>char <span style="color: #a52a2a;">*</span> char input<span style="color: #a52a2a;">)</span> option <span style="color: #a52a2a;">=</span> <span style="color: #000000; background-color: #FFFFFF;">Some</span> <span style="color: #a52a2a;">(</span><span style="color: #008000;">'x'</span><span style="color: #a52a2a;">,</span> <span style="color: #6434A3;">LazyStream.</span><span style="color: #000000; background-color: #FFFFFF;">Cons</span> <span style="color: #a52a2a;">(</span><span style="color: #008000;">'y'</span><span style="color: #a52a2a;">,</span> <span style="color: #a52a2a;">&lt;</span><span style="color: #0000FF;">lazy</span><span style="color: #a52a2a;">&gt;))</span>

utop <span style="color: #a52a2a;">#</span> <span style="color: #6434A3;">LazyStream.</span>of_string <span style="color: #008000;">"yz"</span> <span style="color: #a52a2a;">|&gt;</span> pgn_capture<span style="color: #ff4500;">;;</span>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #a52a2a;">(</span>char <span style="color: #a52a2a;">*</span> char input<span style="color: #a52a2a;">)</span> option <span style="color: #a52a2a;">=</span> None
</pre>
</div>

<p>
Looks good! Note that the parser also returns the remainder of the
input.  If we are only interested whether parsing succeeded, we can
use the function <code>parse</code>:
</p>

<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #a52a2a;">#</span> <span style="color: #6434A3;">LazyStream.</span>of_string <span style="color: #008000;">"xyz"</span> <span style="color: #a52a2a;">|&gt;</span> parse pgn_capture<span style="color: #ff4500;">;;</span>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> char option <span style="color: #a52a2a;">=</span> <span style="color: #000000; background-color: #FFFFFF;">Some</span> <span style="color: #008000;">'x'</span>
</pre>
</div>

<p>
Here are some more simple parsers, defined by the &ldquo;or&rdquo; combinator
<code>&lt;|&gt;</code>, or by spelling out a list of possible
characters to match. 
</p>

<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #a52a2a;">#</span> <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #BA36A5;">pgn_castle</span> <span style="color: #a52a2a;">=</span> token <span style="color: #008000;">"O-O"</span> <span style="color: #a52a2a;">&lt;|&gt;</span> token <span style="color: #008000;">"O-O-O"</span><span style="color: #ff4500;">;;</span>
utop <span style="color: #a52a2a;">#</span> <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #BA36A5;">pgn_piece</span> <span style="color: #a52a2a;">=</span> one_of <span style="color: #a52a2a;">[</span><span style="color: #008000;">'K'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'Q'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'R'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'B'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'N'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'P'</span><span style="color: #a52a2a;">]</span><span style="color: #ff4500;">;;</span>
utop <span style="color: #a52a2a;">#</span> <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #BA36A5;">pgn_file</span> <span style="color: #a52a2a;">=</span> one_of <span style="color: #a52a2a;">[</span><span style="color: #008000;">'a'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'b'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'c'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'d'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'e'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'f'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'g'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'h'</span><span style="color: #a52a2a;">]</span><span style="color: #ff4500;">;;</span>
utop <span style="color: #a52a2a;">#</span> <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #BA36A5;">pgn_rank</span> <span style="color: #a52a2a;">=</span> one_of <span style="color: #a52a2a;">[</span><span style="color: #008000;">'1'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'2'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'3'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'4'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'5'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'6'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'7'</span><span style="color: #a52a2a;">;</span> <span style="color: #008000;">'8'</span><span style="color: #a52a2a;">]</span><span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
Now let&rsquo;s see if we can combine some parsers to match a move.  Here&rsquo;s a bit of
black magic:
</p>

<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #a52a2a;">#</span> <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #BA36A5;">pgn_square</span> <span style="color: #a52a2a;">=</span> pgn_file <span style="color: #a52a2a;">&gt;&gt;=</span> <span style="color: #0000FF;">fun</span> <span style="color: #BA36A5;">file</span> <span style="color: #a52a2a;">-&gt;</span> 
                        pgn_rank <span style="color: #a52a2a;">&gt;&gt;=</span> <span style="color: #0000FF;">fun</span> <span style="color: #BA36A5;">rank</span> <span style="color: #a52a2a;">-&gt;</span> return <span style="color: #a52a2a;">(</span>file<span style="color: #a52a2a;">,</span> rank<span style="color: #a52a2a;">)</span><span style="color: #ff4500;">;;</span>
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #006699;">pgn_square</span> <span style="color: #a52a2a;">:</span> char input <span style="color: #a52a2a;">-&gt;</span> <span style="color: #a52a2a;">((</span>char <span style="color: #a52a2a;">*</span> char<span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">*</span> char input<span style="color: #a52a2a;">)</span> option <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">&lt;</span><span style="color: #0000FF;">fun</span><span style="color: #a52a2a;">&gt;</span>
</pre>
</div>

<p>
Whoah! What&rsquo;s going on there?  Let&rsquo;s see.  If you peek at the source
code of Opal, you&rsquo;ll see that the operator <code>&gt;&gt;=</code> takes a parser (<code>pgn_file</code>) and a function (<code>fun file -&gt;
...</code>).  It will return a new parser that applies <code>pgn_file</code> first and
if it succeeds, hands off the result and the remaining input to the
function.  But wait, <code>fun file -&gt; ...</code> only takes one argument?!
That&rsquo;s because it&rsquo;s <i>partially applied</i>.  It takes one argument now
and the other argument later.  Remember that the second argument is
the remaining input, so it will be a function still looking for
remaining input, hence â€“ a parser!
</p>

<p>
However, it doesn&rsquo;t stop here.  Our anonymous function runs runs
<code>pgn_rank</code> on the remaining input, and again hands off the result and
the remaining input to another anonymous function.  At some point this
madness has to stop:  the function <code>return</code> takes two arguments.  The
first is supplied by the pair <code>(file, rank)</code>.  The second is the
remaining input that we&rsquo;re still carrying around.  The combination of
<code>&gt;&gt;=</code> (called <i>bind</i>) and <code>return</code> is extremely powerful!  With <code>&gt;&gt;=</code>,
you run parsers sequentially, and with <code>return</code>, you can specify the
format of the return value.   If all of this went a little too fast
for you, check out <a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Scott Wlaschin&rsquo;s excellent tutorial on parser combinators</a>.
</p>

<p>
(Exercise:  Implement a parser combinator that takes two parsers
<code>p1</code> and <code>p2</code> and
returns a parser that ignores the result of
the <code>p1</code>, returning only the result of <code>p2</code>.)
</p>
</div>
</div>

<div id="outline-container-org21cb1ff" class="outline-2">
<h2 id="org21cb1ff">The PGN format</h2>
<div class="outline-text-2" id="text-org21cb1ff">
<p>
Let&rsquo;s jump right in and start writing a parser for the <a href="https://www.chessclub.com/user/help/PGN-spec">PGN format</a>.
Here&rsquo;s a sample game in PGN from the specification:
</p>

<pre class="example">
[Event "F/S Return Match"]
[Site "Belgrade, Serbia JUG"]
[Date "1992.11.04"]
[Round "29"]
[White "Fischer, Robert J."]
[Black "Spassky, Boris V."]
[Result "1/2-1/2"]

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 {This opening is called the Ruy Lopez.}
4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8 10. d4 Nbd7
11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5
Nxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6
23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5
hxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5
35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6
Nf2 42. g4 Bd3 43. Re6 1/2-1/2
</pre>

<p>
As you can see, the moves are in SAN format which we already know,
followed by a result that&rsquo;s either <code>1/2-1/2</code>, <code>1-0</code>, <code>0-1</code> or <code>*</code>
(unfinished game).
The header of the file is a list of key-value pairs of metadata.
Comments can be inserted after a move enclosed in curly braces.  Let&rsquo;s
call the set of features seen in this example &ldquo;Simple PGN&rdquo;.
</p>

<p>
There are a few more things you can find in a PGN file, though. PGN
may contain variations (move sequences that were not
played, but are included for analysis), and variations can contain
comments and they can even be nested.  Some header items can carry
special meaning (for instance, if the game starts from a specified position).
</p>
</div>
</div>

<div id="outline-container-orgae27bb8" class="outline-2">
<h2 id="orgae27bb8">A parser for Simple PGN</h2>
<div class="outline-text-2" id="text-orgae27bb8">
<p>
Let&rsquo;s address Simple PGN first.
</p>
</div>
</div>


<div id="outline-container-orgf5006b9" class="outline-2">
<h2 id="orgf5006b9">A parser for PGN</h2>
</div>
</div>
</body>
</html>
